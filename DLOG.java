
import java.io.*;
import java.util.*;
import java.lang.*;
import edu.gsu.cs.dbengine.*;

// This class will print the formatted Program provided by the user to standard
// out
public class DLOG {
    public static void main(String[] args) {
       // We place the initialization of the database, which is passed
       //  as a command line argument, into a try-catch block - if
       //  the database cannot be initialized, exit the program
       try {
           Relation.initializeDatabase(args[0]);
       } catch (Exception e) {
           System.out.println("\nUsage: java DLOG `directory name`.\n");
           System.exit(1);
       }
        
       // Create a relation so we can query the database
       Relation r = null;

       System.out.print("DLOG> ");

       // The prompt of the interpreter is within a do-while loop, which can
       // be terminated by entering "exit"
       do {
           try {

               // We create a Scanner object to read tokens from the standard in
               // stream - these will be our DLOG files provided by the user
               Scanner fileScanner = new Scanner(System.in); 
               String DLOGQFile = fileScanner.next();

               // Break loop and exit program if user enters "exit"
               if (DLOGQFile.equalsIgnoreCase("exit")) {
                   break;
                    
               // If the user input is not preceeded by "@" and teminated with ";"
               // then the input is invalid - the user is prompted again
               } else if (!(DLOGQFile.substring(0,1).equals("@")) || 
                           !(DLOGQFile.substring(DLOGQFile.length()-1, 
                               DLOGQFile.length()).equals(";"))) {

                   System.out.println("\nInvalid input.\nUsage:     @filename;\n");
                   System.out.print("DLOG> ");
                   continue;

               } else { 

                   // Parse out the "@" and ";" from the user's input and send this
                   // to a file Reader object
                   DLOGQFile = DLOGQFile.substring(1,DLOGQFile.length()-1);
               }

               // Now we create a reader object and give it the user's parsed input
               //  - in the event of a FileNotFoundException, the user is prompted 
               //  again
               Reader reader;
               try {
                   reader = new FileReader(DLOGQFile);
               } catch (FileNotFoundException e) {
                   System.out.println("\nFile " + DLOGQFile + 
                           " does not exist.\n");
                   System.out.print("DLOG> ");
                   continue;
               }

               // The parser and Lexer objects are created in the parser.java and
               // Lexer.java files, respectively - The parser takes the Lexer as 
               // an argument - the value variable generated by the parse() 
               // method will return the topmost grammar construct, which in this
               // case is a Program object
               parser p = new parser(new Lexer(reader));                       

               Program treeTop = (Program) p.parse().value;
               System.out.println("\n----------------------------Input Query-----" +
                       "-----------------------\n");

               // displayDLOGProgram will accept a Program object and print it 
               // to standard out
               displayDLOGQProgram(treeTop, r);
               System.out.println("--------------------------------------" +
                       "------------------------------\n");

           } catch (Exception e) {
               System.out.println("\nSYNTAX ERROR\n");
               e.printStackTrace();
           }

           System.out.print("DLOG> ");
       } while (true); 

       System.out.println("\nExiting...\n");
    }

  
    // This class method will recieve a Program object, put the Rules it 
    // contains into a Vector<Rule>, and call displayDLOGRules on each in turn
    // - the effect will be to adequately print the formatted Program to standard
    // out - it will also perform semantic checks on each Rule - code for 
    // semantic checks are stored in separate classes
    private static void displayDLOGQProgram(Program tProgram, Relation r) {
        //boolean predicateChecksOK;
        //tProgram.answerPredicateCheck();
        Vector<Rule> programRules = new Vector<Rule>();
        programRules = tProgram.getRules();

        for (int i = 0; i < programRules.size(); i++) {
            Rule rule = programRules.get(i);
            displayDLOGQRules(rule);
            System.out.println();
            //SafetyCheck.safeCheck(rule);
            //SafetyCheck.checkNegatedBodyPredicates(rule);
            //SchemaCheck.regularBodyPredicateCheck(rule);
            
        }

        boolean safe = tProgram.safetyCheck();

        if (!safe) {
            return;
        }

        boolean answerPredicateCheck = tProgram.answerPredicateCheck();

        if (!answerPredicateCheck) {
            return;
        }

        boolean regularBodyPredicateCheck = tProgram.regularBodyPredicateCheck();

        if (!regularBodyPredicateCheck) {
            return;
        }

        boolean headPredicateCheck = tProgram.headPredicateCheck();

        if (!headPredicateCheck) {
            return;
        }

        boolean recursiveQueryCheck = tProgram.recursiveQueryCheck();

        if (!recursiveQueryCheck) {
            return;
        }
        
        boolean typesChecked = tProgram.getStratifiedIDBPredicate();

        if (!typesChecked) {
            return;
        }

        boolean arityWasChecked = tProgram.arityCheck();

        if (!arityWasChecked) {
           return;
        }

        boolean allConstantsWereChecked = tProgram.checkAllConstantsInProgram();

        if (!allConstantsWereChecked) {
            return;
        }

        boolean allVariablesWereChecked = tProgram.checkAllVariablesInProgram();

        if (!allVariablesWereChecked) {
            return;
        }
    }

    // Here we have the bulk of the code for displaying Programs in standard out
    // - the method recieves a Rule object, separates it into head predicate, 
    // regular body predicates and comparison body predicates and formats 
    // accordingly
    private static void displayDLOGQRules(Rule tRule) {

        // Here we get the Rule's head Predicate - we must set the boolean 
        // isHeadPredicate to true, since we pass all regular predicates to
        // a generic method which knows nothing of head vs body - we could 
        // have used a different method for displaying regular head predicates
        // and regular body predicates, but I don't see how that would reduce 
        // complexity
        Predicate ruleHeadPredicate = tRule.getHeadPredicate();
        ruleHeadPredicate.setIsHeadPredicate(true);

        // We must route the Predicate to different display methods, depending on
        // whether this is a regular predicate or a comparison predicate - of 
        // course, according to the DLOG grammar, the head Predicate of a Rule
        // cannot be a comparison Predicate, so this bit of code is redundant, 
        // but I see no harm in leaving it as an additional check
        if (ruleHeadPredicate.getIsComparison()) {
            displayDLOGQComparisonPredicates(ruleHeadPredicate);
        } else {
            displayDLOGQRegularPredicates(ruleHeadPredicate);
        }

        System.out.print(" ::- \n");

        // Now we are to the body Predicates - we call the Rule object's
        // setBodyPredicates() method, which will populate the Rule object's
        // regular bosy predicate and comparison body predicate Vectors 
        // internally - to set them to Vectors we create in this file, we 
        // need only call the respective get() methods
        tRule.setBodyPredicates(tRule.getBodyPredicates());
        Vector<Predicate> ruleRegularBodyPredicates = 
            tRule.getRegularBodyPredicates();
        Vector<Predicate> ruleComparisonBodyPredicates = 
            tRule.getComparisonBodyPredicates();

        System.out.print("    ");
        
        // We enter here only if there are regular body predicates - it is 
        // possible, according to the grammar, that there are none - 
        // We call class method displayRegularBodyPredicates() for each -
        // if the loop is in the last iteration, and 
        // Vector ruleComparisonBodyPredicates is empty, then we are on the 
        // final Predicate of the Program, which has implications for formatting
        // so we must set boolean isLastPredicate to true
        if (!ruleRegularBodyPredicates.isEmpty()) {
            for (int i = 0; i < ruleRegularBodyPredicates.size(); i++) {       
                if ((i == ruleRegularBodyPredicates.size() - 1) &&
                        (ruleComparisonBodyPredicates.isEmpty())) {
                    ruleRegularBodyPredicates.get(i).setIsLastPredicate(true);
                }

                displayDLOGQRegularPredicates
                    (ruleRegularBodyPredicates.get(i));
            } 
        } 

        // Now the same for the comparison body predicates, if there are any, 
        // except we need not check whether a comparison body predicate is the 
        // last Predicate in the Program - if there ARE comparison body 
        // Predicates, then the last Predicate in the Program will necessarily
        // be a comparison body Predicate - we just print a "." after the 
        // loop terminates
        if (!ruleComparisonBodyPredicates.isEmpty()) {
            for (int i = 0; i < ruleComparisonBodyPredicates.size(); i++) {
                displayDLOGQComparisonPredicates
                    (ruleComparisonBodyPredicates.get(i));
                if ((ruleComparisonBodyPredicates.size()) > 1 &&
                        (i < ruleComparisonBodyPredicates.size() - 1)) {
                    System.out.print(", ");
                }
            }
            System.out.print(".\n");
        }
    }

    // This method parses out the arguments of regular (body or head) Predicate
    // and sends them to displaYDLOGQArguments to be displayed
    private static void displayDLOGQRegularPredicates
        (Predicate tRegularPredicate) {
            
            // Check to see if Predicate is negated - if so, we'll need to print
            // a 'not' iin front of the Predicate's name
            if (tRegularPredicate.getIsNegated()) {
                System.out.print("not ");
            }

            System.out.print(tRegularPredicate.getPredName() + "(");

            // Invoke Predicate's getArguments() method, which returns arguments
            // in a Vector
            Vector<Argument> regularPredicateArguments = 
                tRegularPredicate.getArguments();

            // Loop through all Predicate Arguments and display them - 
            // if the Predicate is NOT the last in a list, follow it with
            // a ", "
            for (int i = 0; i < regularPredicateArguments.size(); i++) {
                displayDLOGQArguments(regularPredicateArguments.get(i));
                if ((regularPredicateArguments.size() > 1) &&
                        (i < regularPredicateArguments.size() - 1)) {
                    System.out.print(",");
                }
            }

            // If the Predicate is NOT the head Predicate and NOT the last
            // Predicate in a list, follow it with ")," and skip to a new line
            // - if it is not the head Predicate but is the last Predicate,
            // follow it with ")." - otherwise just follow it with ")" 
            // (this means it was the head Predicate)
            if (!tRegularPredicate.getIsHeadPredicate() && 
                    !tRegularPredicate.getIsLastPredicate()) {
                System.out.print("),\n");
                System.out.print("    ");
            } else if (tRegularPredicate.getIsLastPredicate()) {
                System.out.println(").");
            } else {
                System.out.print(")");
            }
    }

    // Here we display the Arguments of a comparison body Predicate, of which 
    // there are only two - if the comparison body Predicate is negated, we
    // print "not" in front
    private static void displayDLOGQComparisonPredicates
        (Predicate tComparisonPredicate) {

            // Comparison Predicates can be negated as well, so first we need to
            // check the Predicate's isNegated boolean and, if set to true, 
            // print "not" in front of the left operand
            if (tComparisonPredicate.getIsNegated()) {
                System.out.print("not ");
            }

            // An invocation of getArguments() is irrelevant for a comparison       
            // body Predicate and will fail - instead, we use getLeftOperand()
            // and getRightOperand() - The comparison operator is retrieved with 
            // getComparisonOperator()
            displayDLOGQArguments(tComparisonPredicate.getLeftOperand());
            System.out.print(" " + tComparisonPredicate.getComparisonOperator()
                    + " "); 
            displayDLOGQArguments(tComparisonPredicate.getRightOperand());
    }

    // Our simplest display method - we are now at the leaves of the parse tree
    //  - if the boolean variable isConstant is set to true for the Argument,
    //  we invoke getArgValue(), which will return a decimal number(in String
    //  form) or a String enclosed in ' ' - otherwise, we invoke getArgName, 
    //  because we are dealing with a variable - this will begin with either a 
    //  capital letter or an underscore
    private static void displayDLOGQArguments(Argument tArgument) {
        if (tArgument.getIsConstant() == true) {
            System.out.print(tArgument.getArgValue());
        } else {
            System.out.print(tArgument.getArgName());
        }
    }
}
